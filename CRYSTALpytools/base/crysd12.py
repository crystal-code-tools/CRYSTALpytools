#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Classes and methods of keywords used in 'crystal' input file (d12).
"""
from CRYSTALpytools.base.inputbase import BlockBASE
import numpy as np


class Crystal_inputBASE(BlockBASE):
    """
    The base class of Crystal_input class

    Args:
        geba (bool): Whether it is a normal d12 object or a GEBA subblock
    """

    def __init__(self, geba=False):
        if geba == False:
            # These are dummy keys, not printed out
            dic = {
                'GEOM'     : ['_geom', True, [], 'crysd12.Geom()'],
                'BASISSET' : ['_basisset', True, [], 'crysd12.BasisSet()'],
                'SCF'      : ['_scf', True, [], 'crysd12.SCF()'],
            }
        else:
            dic = {
                'GEOM'     : ['_geom', True, [], 'crysd12.Geom()'],
                'BASISSET' : ['_basisset', True, [], 'crysd12.BasisSet()'],
            }
        # Initialize the object to empty values
        super().__init__('', '', dic)

    @property
    def geom(self):
        """
        Geometry subblock
        """
        self._geom._block_valid = True
        return self._geom

    @property
    def basisset(self):
        """
        Basis set subblock
        """
        self._basisset._block_valid = True
        return self._basisset

    @property
    def scf(self):
        """
        SCF subblock
        """
        self._scf._block_valid = True
        return self._scf

    @property
    def data(self):
        """
        Settings in all the attributes are summarized here.
        """
        import warnings

        if self._block_valid == False:
            warnings.warn("This block is not visible. Set 'self._block_valid = True' to get data",
                          stacklevel=2)
            return ''

        # If objects are set separately, BASISSET might coincide with 'ENDGEOM'
        if np.all(self._basisset._block_dict['BASISSET'][0]!=None) and \
           np.all(self._geom._block_ed!=''):
            self._geom._block_ed = ''

        self.update_block()
        text = ''
        for i in [self._block_bg, self._block_data, self._block_ed]:
            text += i
        return text

    def analyze_text(self, data):
        """
        Analyze formatted d12 file. A 'complete' d12 file with geometry, basis
        set and SCF blocks is suggested.

        Args:
            data (str): Formatted string.
        """
        import re

        data_lines = data.strip().split('\n')

        # initialization
        self.geom()
        self.basisset()
        self.scf()

        # Divide data into 3 blocks
        text = ['', '', '']
        # Case 1: No BASISSET keyword
        if 'BASISSET' not in data:
            geom_end = 1
            bs_end = 2
            end_counter = 0
            block_counter = 0
            subblock_key = ['OPTGEOM', 'FREQCALC',
                            'ANHARM', 'CPHF', 'CPKS', 'ELASTCON', 'EOS']
            for d in data_lines:
                d = d.strip()
                text[block_counter] += d + '\n'
                if d in subblock_key:
                    geom_end += 1
                    bs_end += 1
                elif 'END' in d:
                    end_counter += 1

                if end_counter == geom_end:
                    geom_end = -1
                    block_counter += 1
                elif end_counter == bs_end:
                    bs_end = -1
                    block_counter += 1
        # Case 2: BASISSET keyword
        else:
            self.basisset._block_ed = ''
            self.geom._block_ed = ''
            block_counter = 0
            for d in data_lines:
                d = d.strip()
                if d == 'BASISSET':
                    block_counter += 1
                    text[block_counter] += d + '\n'
                elif d in self.scf._block_key and block_counter == 1:  # Avoid same keywords. e.g. TOLDEE
                    block_counter += 1
                    text[block_counter] += d + '\n'
                else:
                    text[block_counter] += d + '\n'

        # The 0D geometry keyword 'MOLECULE' and the molecular crystal option 'MOLECULE'
        if 'MOLECULE' not in data_lines[1] and 'MOLECULE' in text[0]:
            text[0] = re.sub('MOLECULE', 'MOLECULE2', text[0])

        self.geom.analyze_text(text[0])
        self.basisset.analyze_text(text[1])
        self.scf.analyze_text(text[2])

        return self


class Geom(BlockBASE):
    """
    Geometry block object
    """

    def __init__(self):
        bg = 'Generated by CRYSTALpytools\n'  # Set title as bg label
        ed = 'ENDGEOM\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        geom = ['CRYSTAL', 'SLAB', 'POLYMER', 'HELIX', 'MOLECULE', 'EXTERNAL', 'DLVINPUT']
        scel = ['SUPERCEL', 'SUPERCELL', 'SUPERCON', 'SCELCONF', 'SCELPHONO']
        dic = {
            'CRYSTAL'   : [None, False, geom],
            'SLAB'      : [None, False, geom],
            'POLYMER'   : [None, False, geom],
            'HELIX'     : [None, False, geom],
            'MOLECULE'  : [None, False, geom],
            'EXTERNAL'  : [None, False, geom],
            'DLVINPUT'  : [None, False, geom],
            # ---- supercell ----
            'SUPERCEL'  : [None, False, scel],
            'SUPERCELL' : [None, False, scel],
            'SUPERCON'  : [None, False, scel],
            'SCELCONF'  : [None, False, scel],
            'SCELPHONO' : [None, False, scel],
            # ---- editing ----
            'ATOMBSSE'  : [None, False, []],
            'ATOMDISP'  : [None, False, []],
            'ATOMINSE'  : [None, False, []],
            'ATOMORDE'  : [None, False, []],
            'ATOMREMO'  : [None, False, []],
            'ATOMSUBS'  : [None, False, []],
            'MOLECULE2' : [None, False, []], # The original 'MOLECULE' option to isolate molecules. The key does not change printed out text.
            'ELASTIC'   : [None, False, []],
            # ---- print ----
            'EXTPRT'    : [None, False, []],
            'CIFPRT'    : [None, False, []],
            'CIFPRTSYM' : [None, False, []],
            'COORPRT'   : [None, False, []],
            'TESTGEOM'  : [None, False, ['TESTGEOM', 'OPTGEOM', 'FREQCALC']],
            # ---- blocks ----
            'OPTGEOM'   : ['_optgeom', True, ['TESTGEOM', 'OPTGEOM', 'FREQCALC'], 'crysd12.Optgeom()'],
            'FREQCALC'  : ['_freqcalc', True, ['TESTGEOM', 'OPTGEOM', 'FREQCALC'], 'crysd12.Freqcalc()'],
        }
        self._block_valid = True
        super().__init__(bg, ed, dic)

    def __call__(self, obj=''):
        """
        Call Geom subblock

        Args:
            obj (Geom | str): A 'GEOM' block object or a string in CRYSTAL d12
            format.
        """
        if type(obj) == str:
            self.__init__()
            if np.all(obj!=''):
                self.analyze_text(obj)
        elif np.all(obj==None):
            self.__init__()
            self._block_valid = False
        elif type(obj) == type(self):
            self = obj
        else:
            raise ValueError('Unknown data type.')

    @property
    def data(self):
        """
        Settings in all the attributes are summarized here. Covers the data
        property in BlockBASE, to address the ambiguity of 'MOLECULE' keywords.
        """
        import re, warnings

        if self._block_valid == False:
            warnings.warn("This block is not visible. Set 'self._block_valid = True' to get data",
                          stacklevel=2)
            return ''

        self.update_block()
        text = ''
        for i in [self._block_bg, self._block_data, self._block_ed]:
            text += i
        return re.sub('MOLECULE2', 'MOLECULE', text)

    def analyze_text(self, text):
        """
        Overrides the same method from parent class for title line.
        """
        dimen_list = ['CRYSTAL\n', 'SLAB\n', 'POLYMER\n', 'MOLECULE\n',
                      'HELIX\n', 'EXTERNAL\n', 'DLVINPUT\n']
        lines = text.split('\n')
        nlines = len(lines)
        title = lines[0]
        if title not in dimen_list: # Have title line
            self.title(title)
            text = ''.join([lines[i]+'\n' for i in range(1, nlines)])
        self = super().analyze_text(text)
        return self

    def title(self, title='Generated by CRYSTALpytools'):
        if np.all(title==None) or np.all(title==''):
            title='Generated by CRYSTALpytools'
        self._block_bg = '{}\n'.format(title)

    def crystal(self, IGR='', latt=[], atom=[], IFLAG=0, IFHR=0, IFSO=0, origin=[]):
        """
        Define 'CRYSTAL' structure

        Args:
            sg (int): Space group number. Parameter IGR in the manual
            latt (list): Minimal set of crystallographic cell parameters
            atom (list): Natom \* 4 list of conventional atomic number and 3D 
                fractional coordinates.
            IFLAG (int): See the manual
            IFHR (int): See the manual
            IFSO (int): See the manual
            origin (list): *IFSO > 1* See the manual
        """
        if np.all(IGR=='') or np.all(IGR==None):  # Keyword only or remove everything
            super().assign_keyword('CRYSTAL', [], IGR); return self

        if IFSO <= 1:
            shape = [3, 1]
            value = ['{:<3d}'.format(int(IFLAG)), '{:<3d}'.format(int(IFHR)), '{:<3d}'.format(int(IFSO)),
                     '{:<3d}'.format(int(IGR))]
        else:
            shape = [3, 3, 1]
            value = ['{:<3d}'.format(int(IFLAG)), '{:<3d}'.format(int(IFHR)), '{:<3d}'.format(int(IFSO)),
                     '{:<12.6f}'.format(origin[0]), '{:<12.6f}'.format(origin[1]), '{:<12.6f}'.format(origin[2]),
                     '{:<3d}'.format(int(IGR))]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 12.8f}'.format(a[2]), '{0: 12.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('CRYSTAL', shape, value); return self

    def slab(self, IGR='', latt=[], atom=[]):
        """
        Define 'SLAB' structure
        """
        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('SLAB', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 12.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('SLAB', shape, value); return self

    def polymer(self, IGR='', latt=[], atom=[]):
        """
        Define 'POLYMER' structure
        """
        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('POLYMER', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('POLYMER', shape, value); return self

    def helix(self, N1='', N2=0, latt=[], atom=[]):
        """
        Define 'HELIX' structure

        Args:
            N1 (int): See the manual
            N2 (int): See the manual
        """
        if np.all(N1==None) or np.all(N1==''):  # Return keyword or Clean data
            super().assign_keyword('HELIX', [], N1); return self

        shape = [2, ]
        value = ['{:<3d}'.format(int(N1)), '{:<3d}'.format(int(N2)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('HELIX', shape, value); return self

    def molecule(self, IGR='', atom=[]):
        """
        Define 'MOLECULE' structure
        """
        import warnings

        # The 0D geometry keyword 'MOLECULE' and the molecular crystal option 'MOLECULE'
        geom = ['CRYSTAL', 'SLAB', 'POLYMER', 'HELIX', 'MOLECULE', 'EXTERNAL', 'DLVINPUT']
        for i in geom:
            if np.all(self._block_dict[i][0]!=None):
                warnings.warn("Geometry definition exists. To launch the MOLECULE to isolate molecules from lattice, use the 'geom.molecule2' method.",
                              stacklevel=2)

        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('MOLECULE', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 16.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('MOLECULE', shape, value); return self

    def external(self, external=''):
        """
        Define 'EXTERNAL' structure
        """
        super().assign_keyword('EXTERNAL', [], external); return self

    def dlvinput(self, dlvinput=''):
        """
        Define 'DLVINPUT' structure
        """
        super().assign_keyword('DLVINPUT', [], dlvinput); return self

    # ---- supercell ----

    def supercel(self, mx=''):
        """
        Supercell by 'SUPERCEL' keyword

        Args:
            mx (array | list | str): ndimen \* ndimen matrix, ``None`` or ``''``
        """
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SUPERCEL', shape, value); return self

    def supercon(self, mx=''):
        """
        Supercell by 'SUPERCON' keyword
        """
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SUPERCON', shape, value); return self

    def scelconf(self, mx=''):
        """
        Supercell by 'SCELCONF' keyword
        """
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SCELCONF', shape, value); return self

    def scelphono(self, mx=''):
        """
        Supercell by 'SCELPHONO' keyword
        """
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SCELPHONO', shape, value); return self

    # ---- editing ----

    def elastic(self, IDEF='', mx=''):
        shape = [1,]
        value = [IDEF,]
        out1, out2 = super().set_matrix(mx)
        shape.extend(out1)
        value.extend(out2)
        super().assign_keyword('ELASTIC', shape, value); return self

    def atombsse(self, IAT='', NSTAR=None, RMAX=None):
        super().assign_keyword('ATOMBSSE', [3, ], [IAT, NSTAR, RMAX]); return self

    def atomdisp(self, NDISP='', atom=[]):
        """
        ATOMDISP keyword

        Args:
            NDISP (int): See manual
            atom (list): NDISP\*4 list. Including LB, DX, DY, DZ
        """
        shape, value = super().set_list(NDISP, atom)
        super().assign_keyword('ATOMDISP', shape, value); return self

    def atominse(self, NINS='', atom=[]):
        """
        ATOMINSE keyword

        Args:
            NINS (int): See manual
            atom (list): NINS\*4 list. Including NA, X, Y, Z
        """
        shape, value = super().set_list(NINS, atom)
        super().assign_keyword('ATOMINSE', shape, value); return self

    def atomorde(self, atomorde=''):
        super().assign_keyword('ATOMORDE', [], atomorde); return self

    def atomremo(self, NL='', atom=[]):
        """
        ATOMREMO keyword

        Args:
            NL (int): See manual
            atom (list): NL\*1 list. Including LB
        """
        shape, value = super().set_list(NL, atom)
        super().assign_keyword('ATOMREMO', shape, value); return self

    def atomsubs(self, NSOST='', atom=[]):
        """
        ATOMSUBS keyword

        Args:
            NSOST (int): See manual
            atom (list): NSOST\*2 list. Conventional atomic number of atoms to
                be substituted and to substituted
        """
        shape, value = super().set_list(NSOST, atom)
        super().assign_keyword('ATOMSUBS', shape, value); return self

    def molecule2(self, NMOL='', atom=[]):
        """
        .. note::

            Corresponds to the **option** MOLECULE to isolate molecules from
            lattice. Only the method's name is changed to avoid ambiguity with
            the one to set 0D geometry.

        Args:
            NMOL (int)
            atom (list[list[int]]): NMOL\*4 list. See CRYSTAL manual.
        """
        shape, value = super().set_list(NMOL, atom)
        super().assign_keyword('MOLECULE2', shape, value); return self

    # ---- printing ----

    def extprt(self, extprt=''):
        super().assign_keyword('EXTPRT', [], extprt); return self

    def cifprt(self, cifprt=''):
        super().assign_keyword('CIFPRT', [], cifprt); return self

    def cifprtsym(self, cifprtsym=''):
        super().assign_keyword('CIFPRTSYM', [], cifprtsym); return self

    def coorprt(self, coorprt=''):
        super().assign_keyword('COORPRT', [], coorprt); return self

    def testgeom(self, testgeom=''):
        super().assign_keyword('TESTGEOM', [], testgeom); return self

    # ---- blocks ----

    @property
    def optgeom(self):
        """
        Subblock object OPTGEOM
        """
        self._optgeom._block_valid = True
        return self._optgeom

    @property
    def freqcalc(self):
        """
        Subblock object FREQCALC
        """
        self._freqcalc._block_valid = True
        return self._freqcalc


class Optgeom(BlockBASE):
    """
    OPTGEOM block object
    """

    def __init__(self):
        bg = 'OPTGEOM\n'
        ed = 'ENDOPT\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        opttype = ['FULLOPTG', 'CELLONLY', 'INTREDUN', 'ITATOCEL', 'CVOLOPT']
        hess = ['HESSIDEN', 'HESSMOD1', 'HESSMOD2', 'HESSNUM']
        dic = {
            'FULLOPTG'    : [None, False, opttype],
            'FULLOPTG'    : [None, False, opttype],
            'CELLONLY'    : [None, False, opttype],
            'INTREDUN'    : [None, False, opttype],
            'ITATOCEL'    : [None, False, opttype],
            'CVOLOPT'     : [None, False, opttype],
            'HESSIDEN'    : [None, False, hess],
            'HESSMOD1'    : [None, False, hess],
            'HESSMOD2'    : [None, False, hess],
            'HESSNUM'     : [None, False, hess],
            'TOLDEG'      : [None, False, []],
            'TOLDEX'      : [None, False, []],
            'TOLDEE'      : [None, False, []],
            'MAXCYCLE'    : [None, False, []],
            'FRAGMENT'    : [None, False, []],
            'RESTART'     : [None, False, []],
            'FINALRUN'    : [None, False, []],
            'EXTPRESS'    : [None, False, []],
            'ALLOWTRUSTR' : [None, False, ['NOTRUSTR',]],
            'NOTRUSTR'    : [None, False, ['ALLOWTRUSTR', 'MAXTRADIUS', 'TRUSTRADIUS']],
            'MAXTRADIUS'  : [None, False, ['NOTRUSTR',]],
            'TRUSTRADIUS' : [None, False, ['NOTRUSTR',]],
            'ONELOG'      : [None, False, []],
            'NOXYZ'       : [None, False, []],
            'NOSYMMOPS'   : [None, False, []],
            'PRINTFORCES' : [None, False, []],
            'PRINTHESS'   : [None, False, []],
            'PRINTOPT'    : [None, False, []],
            'PRINT'       : [None, False, []],
            # ---- transition states ----
            'TSOPT'       : [None, False, []],
            'MODEFOLLOW'  : [None, False, []],
            'PATHFOLLOW'  : [None, False, []],
            'FITTOPATH'   : [None, False, []],
            'CHNGTSFOL'   : [None, False, []],
            'SCANATOM'    : [None, False, []],
            'SCANREDU'    : [None, False, []],
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def fulloptg(self, fulloptg=''):
        super().assign_keyword('FULLOPTG', [], fulloptg); return self

    def cellonly(self, cellonly=''):
        super().assign_keyword('CELLONLY', [], cellonly); return self

    def intredun(self, intredun=''):
        super().assign_keyword('INTREDUN', [], intredun); return self

    def itatocel(self, itatocel=''):
        super().assign_keyword('ITATOCEL', [], itatocel); return self

    def cvolopt(self, cvolopt=''):
        super().assign_keyword('CVOLOPT', [], cvolopt); return self

    def hessiden(self, hessiden=''):
        super().assign_keyword('HESSIDEN', [], hessiden); return self

    def hessmod1(self, hessmod1=''):
        super().assign_keyword('HESSMOD1', [], hessmod1); return self

    def hessmod2(self, hessmod2=''):
        super().assign_keyword('HESSMOD2', [], hessmod2); return self

    def hessnum(self, hessnum=''):
        super().assign_keyword('HESSNUM', [], hessnum); return self

    def toldeg(self, TG=0.0003):
        super().assign_keyword('TOLDEG', [1,], TG); return self

    def toldex(self, TX=0.0012):
        super().assign_keyword('TOLDEX', [1,], TX); return self

    def toldee(self, IG=7):
        super().assign_keyword('TOLDEE', [1,], IG); return self

    def maxcycle(self, MAX=50):
        super().assign_keyword('MAXCYCLE', [1,], MAX); return self

    def fragment(self, NL='', LB=[]):
        """
        Args:
            NL (int | str): Number of atoms. See manual
            LB (list[int]): Label of atoms. See manual
        """
        shape, value = super().set_list(NL, LB)
        super().assign_keyword('FRAGMENT', shape, value); return self

    def restart(self, restart=''):
        super().assign_keyword('RESTART', [], restart); return self

    def finalrun(self, ICODE=4):
        super().assign_keyword('FINALRUN', [1,], ICODE); return self

    def extpress(self, pres=''):
        super().assign_keyword('EXTPRESS', [1,], pres); return self

    def allowtrustr(self, allowtrustr=''):
        super().assign_keyword('ALLOWTRUSTR', [], allowtrustr); return self

    def notrustr(self, notrustr=''):
        super().assign_keyword('NOTRUSTR', [], notrustr); return self

    def maxtradius(self, TRMAX=4.0):
        super().assign_keyword('MAXTRADIUS', [1,], TRMAX); return self

    def trustradius(self, TRADIUS=0.5):
        super().assign_keyword('TRUSTRADIUS', [1,], TRADIUS); return self

    def onelog(self, onelog=''):
        super().assign_keyword('ONELOG', [], onelog); return self

    def noxyz(self, noxyz=''):
        super().assign_keyword('NOXYZ', [], noxyz); return self

    def nosymmops(self, nosymmops=''):
        super().assign_keyword('NOSYMMOPS', [], nosymmops); return self

    def printforces(self, printforces=''):
        super().assign_keyword('PRINTFORCES', [], printforces); return self

    def printhess(self, printhess=''):
        super().assign_keyword('PRINTHESS', [], printhess); return self

    def printopt(self, printopt=''):
        super().assign_keyword('PRINTOPT', [], printopt); return self

    def print(self, prt=''):
        super().assign_keyword('PRINT', [], prt); return self

    # ---- transition states ----

    def tsopt(self, tsopt=''):
        super().assign_keyword('TSOPT', [], tsopt); return self

    def modefollow(self, MODEFOL=''):
        super().assign_keyword('MODEFOLLOW', [1,], MODEFOL); return self

    def pathfollow(self, NPATHFOL=''):
        super().assign_keyword('PATHFOLLOW', [1,], NPATHFOL); return self

    def fittopath(self, NPATHFOL2='', NPATHWEIGHT=''):
        super().assign_keyword('FITTOPATH', [2,], [NPATHFOL2, NPATHWEIGHT]); return self

    def chngtsfol(self, chngtsfol=''):
        super().assign_keyword('CHNGTSFOL', [], chngtsfol); return self

    def scanatom(self, NATSCAN='', TARGET='', MSCAN=''):
        super().assign_keyword('SCANATOM', [3,], [NATSCAN, TARGET, MSCAN]); return self

    def scanredu(self, IREDSCA='', ENDSCA='', MAXSCA=''):
        super().assign_keyword('SCANREDU', [3,], [IREDSCA, ENDSCA, MAXSCA]); return self


class Freqcalc(BlockBASE):
    """
    FREQCALC block object
    """

    def __init__(self):
        bg = 'FREQCALC\n'
        ed = 'ENDFREQ\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'NOOPTGEOM'  : [None, False, ['NOOPTGEOM', 'PREOPTGEOM']],
            'PREOPTGEOM' : ['_preoptgeom', True, ['NOOPTGEOM', 'PREOPTGEOM'], 'crysd12.Optgeom()'],
            'DISPERSION' : [None, False, []],
            'BANDS'      : [None, False, []],
            'NUMDERIV'   : [None, False, []],
            'STEPSIZE'   : [None, False, []],
            'RESTART'    : [None, False, []],
            'MODES'      : [None, False, ['MODES', 'NOMODES']],
            'NOMODES'    : [None, False, ['MODES', 'NOMODES']],
            'PRESSURE'   : [None, False, []],
            'TEMPERAT'   : [None, False, []],
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def nooptgeom(self, nooptgeom=''):
        super().assign_keyword('NOOPTGEOM', [], nooptgeom); return self

    @property
    def preoptgeom(self):
        """
        Subblock object PREOPTGEOM
        """
        self._preoptgeom._block_valid = True
        # Change the keyword
        self._preoptgeom._block_bg = 'PREOPTGEOM\n'
        self._preoptgeom._block_ed = 'END\n'
        return self._preoptgeom

    def dispersion(self, dispersion=''):
        super().assign_keyword('DISPERSION', [], dispersion); return self

    def bands(self, ISS='', NSUB=None, NLINE=None, points=[]):
        if np.all(ISS==None) or np.all(ISS==''):
            super().assign_keyword('BANDS', [], ISS)
        else:
            shape, value = super().set_list(NLINE, points)
            super().assign_keyword('BANDS', [2, ] + shape, [ISS, NSUB] + value)
        return self

    def modes(self, modes=''):
        super().assign_keyword('MODES', [], modes); return self

    def nomodes(self, nomodes=''):
        super().assign_keyword('NOMODES', [], nomodes); return self

    def numderiv(self, N=1):
        super().assign_keyword('NUMDERIV', [1,], N); return self

    def pressure(self, NP='', P1=None, P2=None):
        super().assign_keyword('PRESSURE', [3,], [NP, P1, P2]); return self

    def restart(self, restart=''):
        super().assign_keyword('RESTART', [], restart); return self

    def stepsize(self, STEP=0.003):
        super().assign_keyword('NUMDERIV', [1,], STEP); return self

    def temperat(self, NT='', T1=None, T2=None):
        super().assign_keyword('TEMPERAT', [3,], [NT, T1, T2]); return self


class BasisSet(BlockBASE):
    """
    Basis Set block object
    """
    def __init__(self):
        bg = ''
        ed = 'ENDBS\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'BASISSET'    : [None, False, []],
            'GHOSTS'      : [None, False, []],
        }
        super().__init__(bg, ed, dic)
        self._bs_obj = None # BasisSetBASE object

    # __call__ method inherited from BlockBASE

    @property
    def data(self):
        """
        Settings in all the attributes are summarized here. Covers the data
        property in BlockBASE, to deal with user's definition of basis sets.
        """
        import warnings

        if self._block_valid == False:
            warnings.warn("This block is not visible. Set 'self._block_valid = True' to get data",
                          stacklevel=2)
            return ''

        self.update_block()
        if np.all(self._block_dict['BASISSET'][0]==None) and np.all(self._bs_obj!=None):
            text = self._block_bg + self._bs_obj.print_crystal()
        else:
            text = self._block_bg

        for i in [self._block_data, self._block_ed]:
            text += i

        return text

    def analyze_text(self, text):
        """
        Analyze the input and return to corresponding attributes. Add support
        to basis set strings
        """
        import re
        from CRYSTALpytools.base.basisset import BasisSetBASE

        super().analyze_text(text)
        lines = self._block_bg.split('\n')
        usrbs = False
        for nline, line in enumerate(lines):
            line = line.strip()
            if re.match(r'^[0-9]+\s+[0-9]+$', line): # If there is a user defined basis set
                line2 = lines[nline+1].strip().split()
                if len(line2) == 5:
                    usrbs = True
                    break

        if usrbs == True: # user defined basis set
            self._block_bg = ''
            self._block_ed = 'ENDBS\n'
            ed = -1
            for nline, line in enumerate(lines):
                line = line.strip()
                if re.match(r'^99\s+0$', line):
                    ed = nline
                    break
            if ed < 0:
                raise ValueError('Valid definition of basis set does not exist')

            bsblock = ''.join([i+'\n' for i in lines])
            self._bs_obj = BasisSetBASE.from_string(bsblock)
        else: # keyword
            self._block_ed = ''

        return self

    # ---------------- Keywords ----------------
    def basisset(self, NAME=''):
        import warnings

        if np.all(NAME==None):
            self._block_ed = 'ENDBS\n'
        else:
            self._block_ed = ''
            if np.all(self._bs_obj!=None):
                warnings.warn("User's definition of baisis set is not empty. It will be covered by 'BASISSET' keyword.",
                              stacklevel=2)
                self._bs_obj = None

        super().assign_keyword('BASISSET', [1,], NAME); return self

    def ghosts(self, NA='', LA=[]):
        shape, value = super().set_list(NA, LA)
        super().assign_keyword('GHOSTS', shape, value); return self

    # ---------------- User defined basis sets ----------------
    # Wrapper defined in crystal_io.Crystal_iput()
    def from_bse(self, name, z, append=False):
        """
        Download basis set definitions from `Basis Set Exchange (BSE) <https://www.basissetexchange.org/>`_.

        Args:
            name (str): Basis set's name.
            z (list[int]): List of elements, specified by conventional atomic
                numbers.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE
        import warnings

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warnings.warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_bse(name, z).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_bse(name, z)

        return self

    def from_string(self, string, fmt='crystal', append=False):
        """
        Basis set from a string

        Args:
            string (str): Basis set definition.
            fmt (str): Format string. Consistent with `BSE <https://www.basissetexchange.org/>`_
                python API. For non-CRYSTAL formats, only all-electron basis
                sets are supported. Charge of each shell will be automatically
                assigned to get charge neutral atoms.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE
        import warnings

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warnings.warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_string(string, fmt).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_string(string, fmt)

        return self

    def from_file(self, file, fmt='crystal', append=False):
        """
        Basis set from a file

        Args:
            file (file): Basis set definition.
            fmt (str): Format string. Consistent with `BSE <https://www.basissetexchange.org/>`_
                python API. For non-CRYSTAL formats, only all-electron basis
                sets are supported. Charge of each shell will be automatically
                assigned to get charge neutral atoms.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE
        import warnings

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warnings.warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_file(file, fmt).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_file(file, fmt)

        return self

    def from_obj(self, bs_obj, append=False):
        """
        Define basis set from a ``base.basisset.BasisSetBASE`` object.

        Args:
            bs_obj (BasisSetBASE)
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE
        import warnings

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warnings.warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(bs_obj.atoms)
        else:
            self._bs_obj = bs_obj

        return self


class SCF(BlockBASE):
    """
    SCF block object
    """
    def __init__(self):
        bg = ''
        ed = 'ENDSCF\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        hamiltonian = ['RHF', 'UHF', 'ROHF', 'HF3C', 'HFSOL3C','DFT']
        dic = {
            'FIXINDEX' : [None, False, []],# Must be here
            # ---- Hamiltonian ----
            'RHF'      : [None, False, hamiltonian],
            'UHF'      : [None, False, hamiltonian],
            'ROHF'     : [None, False, hamiltonian],
            'DFT'      : ['_dft', True, hamiltonian, 'crysd12.DFT()'],# DFT sub-block
            # ---- Semi classical ----
            'HF3C'     : ['_hf3c', True, hamiltonian, 'crysd12.HF3C()'],  # HF3C sub-block
            'HFSOL3C'  : ['_hfsol3c', True, hamiltonian, 'crysd12.HF3C()'],  # HFSOL3C sub-block
            'DFTD3'    : ['_dftd3', True, [], 'crysd12.DFTD3()'],# DFTD3 sub-block
            'GCP'      : ['_gcp', True, ['GCPAUTO'], 'crysd12.GCP()'],# GCP sub-block
            'GCPAUTO'  : [None, False, ['GCP']],
            # ---- Spin ----
            'ATOMSPIN' : [None, False, []],
            # ---- SCF control ----
            'TOLDEE'   : [None, False, []],
            'GUESSP'   : [None, False, []],
            'MAXCYCLE' : [None, False, []],
            'SMEAR'    : [None, False, []],
            'LDREMO'   : [None, False, []],
            'LEVSHIFT' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'BROYDEN']],
            # ---- Integation ----
            'SHRINK'   : [None, False, []],
            'TOLINTEG' : [None, False, ['NOBIPOLA', 'NOBIPCOU', 'NOBIPEXC']],
            'BIPOLAR'  : [None, False, ['NOBIPOLA',]],
            'BIPOSIZE' : [None, False, []],
            'EXCHSIZE' : [None, False, []],
            'NOBIPOLA' : [None, False, ['TOLINTEG', 'BIPOLAR']],
            'NOBIPCOU' : [None, False, ['TOLINTEG']],
            'NOBIPEXC' : [None, False, ['TOLINTEG']],
            # ---- Diagonalization ----
            'FMIXING'  : [None, False, []],
            'ANDERSON' : [None, False, []],
            'BROYDEN'  : [None, False, ['LEVSHIFT']],
            'DIIS'     : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'NODIIS'   : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS']],
            'DIISALLK' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'SLOSHING' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'HISTDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'THREDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'THRKDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'SLOSHFAC' : [None, False, ['DIIS', 'DIISALLK', 'NODIIS', 'LEVSHIFT']],
            'PRTDIIS'  : [None, False, ['NODIIS', 'LEVSHIFT']],
            # ---- Post SCF ----
            'EXCHANGE' : [None, False, []],
            'POSTSCF'  : [None, False, []],
            'PPAN'     : [None, False, []],
            'GRADCAL'  : [None, False, []],
            # ---- MPP ----
            'CMPLXFAC' : [None, False, []],
            'REPLDATA' : [None, False, []],
            'STDIAG'   : [None, False, []],
            # ---- FIXINDEX ----
            'GEOM'     : ['_geom', True, ['GEOM', 'BASE', 'GEBA'], 'crysd12.Geom()'],# FIXINDEX - GEOM subblock. Must be at the end
            'BASE'     : ['_base', True, ['GEOM', 'BASE', 'GEBA'], 'crysd12.BasisSet()'],# FIXINDEX - BASE subblock. Must be at the end.
            'GEBA'     : ['_geba', True, ['GEOM', 'BASE', 'GEBA'], 'crysd12.Crystal_inputBASE(geba=True)'],# FIXINDEX - GEBA subblock. Must be at the end.
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    @property
    def data(self):
        """
        Print formatted input. Redefined to address the END keywords of
        FIXINDEX blocks
        """
        import warnings

        if self._block_valid == False:
            warnings.warn("This block is not visible. Set 'self._block_valid = True' to get data",
                          stacklevel=2)
            return ''

        if self._geom._block_valid == True or self._base._block_valid == True or self._geba._block_valid == True:
            self._block_ed = ''

        self.update_block()
        text = ''
        for i in [self._block_bg, self._block_data, self._block_ed]:
            text += i
        return text

    # ---------------- Hamiltonian ----------------

    def rhf(self, rhf=''):
        super().assign_keyword('RHF', [], rhf)
        return self

    def uhf(self, uhf=''):
        super().assign_keyword('UHF', [], uhf)
        return self

    def rohf(self, NSPIN=''):
        super().assign_keyword('ROHF', [1,], NSPIN)
        return self

    @property
    def dft(self):
        """
        Subblock object DFT
        """
        self._dft._block_valid = True
        return self._dft

    # ---------------- Semi-classical ----------------

    @property
    def hf3c(self):
        """
        Subblock object HF3C
        """
        self._hf3c._block_valid = True
        return self._hf3c

    @property
    def hfsol3c(self):
        """
        Subblock object HFSOL3C
        """
        self._hfsol3c._block_valid = True
        return self._hfsol3c


    @property
    def dftd3(self):
        """
        Subblock object DFTD3
        """
        self._dftd3._block_valid = True
        return self._dftd3

    @property
    def gcp(self):
        """
        Subblock object GCP
        """
        self._gcp._block_valid = True
        return self._gcp

    def gcpauto(self, gcpauto=''):
        super().assign_keyword('GCPAUTO', [], gcpauto); return self

    # ---------------- Spin ----------------

    def atomspin(self, NA='', LA=[]):
        shape, value = super().set_list(NA, LA)
        super().assign_keyword('ATOMSPIN', shape, value); return self

    # ---------------- SCF control ----------------

    def toldee(self, ITOL=6):
        super().assign_keyword('TOLDEE', [1,], ITOL); return self

    def guessp(self, guessp=''):
        super().assign_keyword('GUESSP', [], guessp); return self

    def maxcycle(self, MAX=50):
        super().assign_keyword('MAXCYCLE', [1,], MAX); return self

    def ldremo(self, value=''):
        super().assign_keyword('LDREMO', [1,], value); return self

    def smear(self, WIDTH=''):
        super().assign_keyword('SMEAR', [1,], WIDTH); return self

    def levshift(self, ISHIFT='', ILOCK=''):
        super().assign_keyword('LEVSHIFT', [2,], [ISHIFT, ILOCK]); return self

    # ---------------- Integration ----------------

    def shrink(self, IS='', ISP='', IS1='', IS2='', IS3=''):
        """
        Shrink parameters.
        """
        if np.all(IS1==''):
            super().assign_keyword('SHRINK', [2,], [IS, ISP]); return self
        else:
            super().assign_keyword('SHRINK', [2, 3], [IS, ISP, IS1, IS2, IS3]); return self

    def tolinteg(self, ITOL1=7, ITOL2=7, ITOL3=7, ITOL4=7, ITOL5=14):
        super().assign_keyword('TOLINTEG', [5,], [ITOL1, ITOL2, ITOL3, ITOL4, ITOL5]); return self

    def biposize(self, ISIZE=4000000):
        super().assign_keyword('BIPOSIZE', [1,], ISIZE); return self

    def exchsize(self, ISIZE=4000000):
        super().assign_keyword('EXCHSIZE', [1,], ISIZE); return self

    def bipolar(self, ITCOUL=18, ITEXCH=14):
        super().assign_keyword('BIPOLAR', [2,], [ITCOUL, ITEXCH]); return self

    def nobipola(self, nobipola=''):
        super().assign_keyword('NOBIPOLA', [], nobipola); return self

    def nobipcou(self, nobipcou=''):
        super().assign_keyword('NOBIPCOU', [], nobipcou); return self

    def nobipexc(self, nobipexc=''):
        super().assign_keyword('NOBIPEXC', [], nobipexc); return self

    # ---------------- Diagonalization ----------------

    def fmixing(self, IPMIX=30):
        super().assign_keyword('FMIXING', [1,], IPMIX); return self

    def diis(self, diis=''):
        super().assign_keyword('DIIS', [], diis); return self

    def nodiis(self, nodiis=''):
        super().assign_keyword('NODIIS', [], nodiis); return self

    def diisallk(self, diisallk=''):
        super().assign_keyword('DIISALLK', [], diisallk); return self

    def sloshing(self, sloshing=''):
        super().assign_keyword('SLOSHING', [], sloshing); return self

    def histdiis(self, NCYC=''):
        super().assign_keyword('HISTDIIS', [1,], NCYC); return self

    def thrediis(self, DEDIIS=''):
        super().assign_keyword('THREDIIS', [1,], DEDIIS); return self

    def thrkdiis(self, DIISTHR=''):
        super().assign_keyword('THRKDIIS', [1,], DIISTHR); return self

    def sloshfac(self, FKERK=1.2):
        super().assign_keyword('SLOSHFAC', [1,], FKERK); return self

    def prtdiis(self, prtdiis=''):
        super().assign_keyword('PRTDIIS', [], prtdiis); return self

    def anderson(self, anderson=''):
        super().assign_keyword('ANDERSON', [], anderson); return self

    def broyden(self, W0=0.0001, IMIX=50, ISTART=2):
        super().assign_keyword('BROYDEN', [3,], [W0, IMIX, ISTART]); return self


    # ---------------- Post SCF ----------------

    def ppan(self, ppan=''):
        super().assign_keyword('PPAN', [], ppan); return self

    def gradcal(self, gradcal=''):
        super().assign_keyword('GRADCAL', [], gradcal); return self

    def exchange(self, exchange=''):
        super().assign_keyword('EXCHANGE', [], exchange); return self

    def postscf(self, postscf=''):
        super().assign_keyword('POSTSCF', [], postscf); return self

    # ---------------- MPP ----------------

    def cmplxfac(self, WEIGHT=2.0):
        super().assign_keyword('CMPLXFAC', [1, ], WEIGHT); return self

    def repldata(self, repldata=''):
        super().assign_keyword('REPLDATA', [], repldata); return self

    def stdiag(self, stdiag=''):
        super().assign_keyword('STDIAG', [], stdiag); return self

    # ---------------- FIXINDEX ----------------

    def fixindex(self, fixindex=''):
        """
        Fixindex keywords.

        .. note::
            'GEOM' is a ``Geom`` object. To modify keywords ('CRYSTAL' as
            example), use ``input.scf.geom.crystal()``.

            'BASE' is a ``BasisSet`` object. To define basis set from bse, use
            ``input.scf.base.from_bse()``.

            'GEBA' is a ``Crystal_inputBASE`` object. To modify keywords
            ('CRYSTAL' as example), use ``input.scf.geba.geom.crystal()``.
        """
        super().assign_keyword('FIXINDEX', [], fixindex); return self

    @property
    def geom(self):
        """
        Subblock object GEOM
        """
        self._geom._block_valid = True
        self.fixindex()
        self._geom._block_bg = 'ENDSCF\nGEOM\n'
        self._geom._block_ed = 'END\n'
        return self._geom

    @property
    def base(self):
        """
        Subblock object BASE
        """
        self._base._block_valid = True
        self.fixindex()
        self._base._block_bg = 'ENDSCF\nBASE\n'
        self._base._block_ed = 'END\n'
        return self._base

    @property
    def geba(self):
        """
        Subblock object GEBA
        """
        self._geba._block_valid = True
        self.fixindex()
        self._geba._block_bg = 'ENDSCF\nGEBA\n'
        self._geba._block_ed = 'END\n'
        self._geba.geom._block_bg = ''
        self._geba.geom._block_ed = 'END\n'
        self._geba.basisset._block_ed = ''
        return self._geba


class HF3C(BlockBASE):
    """
    HF3C block object
    """
    def __init__(self):
        bg = 'HF3C\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'RESCALES8' : [None, False, []],
            'SCALEGCP'  : [None, False, []],
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def rescales8(self, s8=''):
        super().assign_keyword('RESCALES8', [1,], s8); return self

    def scalegcp(self, gcp=''):
        super().assign_keyword('SCALEGCP', [1,], gcp); return self


class HFSOL3C(HF3C):
    """
    HFSOL3C block object
    """
    def __init__(self):
        super().__init__()
        self._block_bg = 'HFSOL3C\n'

    # __call__ method inherited from BlockBASE


class DFT(BlockBASE):
    """
    DFT block object
    """
    def __init__(self):
        bg = 'DFT\n'
        ed = 'ENDDFT\n'
        standalone_func = [
            'SVWN', 'BLYP', 'PBEXC', 'PBESOLXC', 'SOGGAXC', 'SOGGA11', 'B3PW',
            'B3LYP', 'PBE0', 'PBESOL0', 'B1WC', 'WC1LYP', 'B97H', 'PBE0-13',
            'SOGGA11X', 'MPW1PW91', 'MPW1K', 'HSE06', 'HSESOL', 'SC-BLYP',
            'HISS', 'RSHXLDA', 'WB97', 'WB97X', 'LC-WPBE', 'LC-WPBESOL',
            'LC-WBLYP', 'LC-BLYP', 'CAM-B3LYP', 'LC-PBE', 'M06L', 'REVM06L',
            'MN15L', 'SCAN', 'R2SCAN', 'B1B95', 'MPW1B95', 'MPW1B1K', 'PW6B95',
            'PWB6K', 'M05', 'M052X', 'M06', 'M062X', 'M06HF', 'MN15', 'REVM06',
            'SCAN0', 'R2SCANH', 'R2SCAN0', 'R2SCAN50', 'MN15',
            'BLYP-D3', 'PBE-D3', 'B97-D3', 'B3LYP-D3', 'PBE0-D3', 'PW1PW-D3',
            'M06-D3', 'HSE06-D3', 'HSESOL-D3', 'LC-WPBE-D3', 'B3LYP-D3',
            'PBEH3C', 'HSE3C', 'B973C', 'PBESOL03C', 'HSESOL3C'
        ]
        user_func = [
            'EXCHANGE', 'CORRELAT', 'HYBRID', 'NONLOCAL'
        ]
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        ## User defined functionals
        dic = {
            'SPIN'     : [None, False, []],
            'EXCHANGE' : [None, False, standalone_func + user_func],
            'CORRELAT' : [None, False, standalone_func + user_func],
            'HYBRID'   : [None, False, standalone_func + user_func],
            'NONLOCAL' : [None, False, standalone_func + user_func],
        }
        ## Standalone functionals
        for func in standalone_func:
            dic[func] = [None, False, standalone_func + user_func]

        ## Control keywords
        grid = ['OLDGRID', 'LGRID', 'XLGRID', 'XXLGRID', 'XXXLGRID', 'HUGEGRID',
                'RADIAL', 'ANGULAR']
        dic.update({
            'SR-OMEGA'     : [None, False,[]],
            'MR-OMEGA'     : [None, False,[]],
            'LR-OMEGA'     : [None, False,[]],
            'SR-HYB-WB97X' : [None, False,[]],
            'LSRSH-PBE'    : [None, False,[]],
            'OLDGRID'      : [None, False, grid],
            'LGRID'        : [None, False, grid],
            'XLGRID'       : [None, False, grid],
            'XXLGRID'      : [None, False, grid],
            'XXXLGRID'     : [None, False, grid],
            'HUGEGRID'     : [None, False, grid],
            'RADIAL'       : [None, False, grid],
            'ANGULAR'      : [None, False, grid],
        })
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def spin(self, spin=''):
        super().assign_keyword('SPIN', [], spin)
        return self

    def exchange(self, ex=''):
        exlist = [
            'LDA', 'VBH', 'BECKE', 'mPW91', 'PBE', 'PBESOL', 'PWGGA', 'SOGGA',
            'WCGGA'
        ]
        if np.all(ex!='') and np.all(ex!=None):
            if ex not in exlist:
                raise ValueError('Unknown exchange functional name.')
        super().assign_keyword('EXCHANGE', [1,], ex)
        return self

    def correlat(self, cor=''):
        corlist = [
            'PWLSD', 'PZ', 'VBH', 'VWN', 'LYP', 'P86', 'PBE', 'PBESOL',
            'PWGGA', 'WL', 'B95'
        ]
        if np.all(cor!='') and np.all(cor!=None):
            if cor not in corlist:
                raise ValueError('Unknown correlation functional name.')
        super().assign_keyword('CORRELAT', [1,], cor)
        return self

    def xcfunc(self, xc=''):
        if np.all(xc!=None) and np.all(xc!=''):
            if xc not in self._block_key:
                raise ValueError('Unknown functional name.')
        super().assign_keyword(xc, [], '')
        return self

    def sr_omega(self, sr_omega=''):
        super().assign_keyword('SR-OMEGA', [1,], sr_omega); return self

    def mr_omega(self, mr_omega=''):
        super().assign_keyword('MR-OMEGA', [1,], mr_omega); return self

    def lr_omega(self, lr_omega=''):
        super().assign_keyword('LR-OMEGA', [1,], lr_omega); return self

    def sr_hyb_wb97x(self, sr_c=''):
        super().assign_keyword('SR-HYB-WB97X', [1,], sr_c); return self

    def lsrsh_pbe(self, omega='', sr_c=0., lr_c=0.):
        super().assign_keyword('LSRSH-PBE', [3,], [omega, sr_c, lr_c]); return self

    def lgrid(self, lgrid=''):
        super().assign_keyword('LGRID', [], lgrid); return self

    def oldgrid(self, oldgrid=''):
        super().assign_keyword('OLDGRID', [], oldgrid); return self

    def xlgrid(self, xlgrid=''):
        super().assign_keyword('XLGRID', [], xlgrid); return self

    def xxlgrid(self, xxlgrid=''):
        super().assign_keyword('XXLGRID', [], xxlgrid); return self

    def xxxlgrid(self, xxxlgrid=''):
        super().assign_keyword('XXXLGRID', [], xxxlgrid); return self

    def hugegrid(self, hugegrid=''):
        super().assign_keyword('HUGEGRID', [], hugegrid); return self

    def radial(self, NR='', RL=[], IL=[]):
        if np.all(NR!=None) and np.all(NR!=''):
            RL = list(RL)
            IL = list(IL)
            if NR != len(IL) and NR != len(RL):
                raise ValueError('Inconsistent definition. NR is not equal to lengths of RL or IL.')
        super().assign_keyword('RADIAL', [1, NR, NR], [NR, ] + RL + IL)
        return self

    def angular(self, NI='', AL=[], LEV=[]):
        if np.all(NI!=None) and np.all(NI!=''):
            AL = list(AL)
            LEV = list(LEV)
            if NI != len(LEV) and NI != len(AL):
                raise ValueError('Inconsistent definition. NI is not equal to lengths of AL or LEV')
        super().assign_keyword('ANGULAR', [1, NI, NI], [NI, ] + AL + LEV)
        return self


class DFTD3(BlockBASE):
    """
    DFTD3 block object
    """

    def __init__(self):
        bg = 'DFTD3\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'VERSION'   : [None, False, []],
            'FUNC'      : [None, False, []],
            'ABC'       : [None, False, []],
            'S6'        : [None, False, []],
            'S8'        : [None, False, []],
            'A1'        : [None, False, ['RS6', 'RS8']],#BJ damping
            'A2'        : [None, False, ['RS6', 'RS8']],#BJ damping
            'RS6'       : [None, False, ['A1', 'A2']],#zero damping
            'RS8'       : [None, False, ['A1', 'A2']],#zero damping
            'RADIUS'    : [None, False, []],
            'CNRADIUS'  : [None, False, []],
            'ABCRADIUS' : [None, False, []],
            'PRINTC6'   : [None, False, []],
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def version(self, NAT=4):
        super().assign_keyword('VERSION', [1,], NAT); return self

    def func(self, CHAR=''):
        super().assign_keyword('FUNC', [1,], CHAR); return self

    def abc(self, abc=''):
        super().assign_keyword('ABC', [], abc); return self

    def s6(self, s6=''):
        super().assign_keyword('S6', [1,], s6); return self

    def s8(self, s8=''):
        super().assign_keyword('S8', [1,], s8); return self

    def a1(self, a1=''):
        super().assign_keyword('A1', [1,], a1); return self

    def a2(self, a2=''):
        super().assign_keyword('A2', [1,], a2); return self

    def rs6(self, rs6=''):
        super().assign_keyword('RS6', [1,], rs6); return self

    def rs8(self, rs8=''):
        super().assign_keyword('RS8', [1,], rs8); return self

    def radius(self, radius=''):
        super().assign_keyword('RADIUS', [1,], radius); return self

    def cnradius(self, cnradius=''):
        super().assign_keyword('CNRADIUS', [1,], cnradius); return self

    def abcradius(self, abcradius=''):
        super().assign_keyword('ABCRADIUS', [1,], abcradius); return self

    def printc6(self, printc6=''):
        super().assign_keyword('PRINTC6', [], printc6); return self


class GCP(BlockBASE):
    """
    GCP block object
    """

    def __init__(self):
        bg = 'GCP\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'METHOD'     : [None, False, []],
            'SIGMA'      : [None, False, []],
            'ALPHA'      : [None, False, []],
            'BETA'       : [None, False, []],
            'ETA'        : [None, False, []],
            'RADIUS'     : [None, False, []],
            'PRINTEMISS' : [None, False, []],
        }
        super().__init__(bg, ed, dic)

    # __call__ method inherited from BlockBASE

    def method(self, method=''):
        super().assign_keyword('METHOD', [1, ], method); return self

    def sigma(self, sigma=''):
        super().assign_keyword('SIGMA', [1, ], sigma); return self

    def alpha(self, alpha=''):
        super().assign_keyword('ALPHA', [1, ], alpha); return self

    def beta(self, beta=''):
        super().assign_keyword('BETA', [1, ], beta); return self

    def eta(self, eta=''):
        super().assign_keyword('ETA', [1, ], eta); return self

    def radius(self, radius=''):
        super().assign_keyword('RADIUS', [1, ], radius); return self

    def printemiss(self, printemiss=''):
        super().assign_keyword('PRINTEMISS', [], printemiss); return self

