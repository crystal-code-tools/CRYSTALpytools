{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "68158073",
   "metadata": {},
   "source": [
    "# Input and Basis Set Generation\n",
    "\n",
    "CRYSTALpytools provides a branch of methods to prepare input files and basis sets interactively. They are kept in the `crystal_io` module.\n",
    "\n",
    "## 'crystal_io.Crystal_input' class\n",
    "\n",
    "**NOTE**\n",
    "\n",
    "**Though developers are working hard to implement all the keywords, due to the limit of time and developing forces, not all keywords has been implemented. Please confirm that in module-specific documentations or contact developers via [GitHub](https://github.com/crystal-code-tools/CRYSTALpytools).**\n",
    "\n",
    "### Basic file generation\n",
    "\n",
    "The `Crystal_input` class accepts keywords and prepare input files for 'crystal' calculations of CRYSTAL package. The user can create a crystal input object by directly calling the methods. Both the name and format of methods are consistent with CRYSTAL keywords. The text input in 'd12' format is accessible by calling the `data` property."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4938ba48-2a8d-4b31-b777-bf641fc327fe",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MGO BULK - GEOMETRY TEST\n",
      "CRYSTAL\n",
      "0   0   0   \n",
      "225 \n",
      "4.217000     \n",
      "2 \n",
      "12     0.00000000   0.00000000   0.00000000 \n",
      "8      0.50000000   0.50000000   0.50000000 \n",
      "BASISSET\n",
      "POB-DZVP \n",
      "DFT\n",
      "B3LYP\n",
      "XXLGRID\n",
      "ENDDFT\n",
      "MAXCYCLE\n",
      "70 \n",
      "SHRINK\n",
      "12 24 \n",
      "TOLINTEG\n",
      "7 7 7 7 14 \n",
      "FMIXING\n",
      "70 \n",
      "DIIS\n",
      "ENDSCF\n",
      "\n"
     ]
    }
   ],
   "source": [
    "from CRYSTALpytools.crystal_io import Crystal_input\n",
    "\n",
    "mgo_input = Crystal_input()\n",
    "mgo_input.geom.title('MGO BULK - GEOMETRY TEST')\n",
    "mgo_input.geom.crystal(225, # Space group\n",
    "                      [4.217], # Minimal set of lattice parameters\n",
    "                      [[12, 0., 0., 0.], # Atomic labels and coordinates\n",
    "                       [8, 0.5, 0.5, 0.5]]\n",
    "                      )\n",
    "mgo_input.basisset.basisset('POB-DZVP')\n",
    "mgo_input.scf.dft.xcfunc('B3LYP')\n",
    "mgo_input.scf.dft.xxlgrid()\n",
    "mgo_input.scf.tolinteg(7, 7, 7, 7, 14)\n",
    "mgo_input.scf.shrink(12, 24)\n",
    "mgo_input.scf.maxcycle(70)\n",
    "mgo_input.scf.fmixing(70)\n",
    "mgo_input.scf.diis()\n",
    "\n",
    "print(mgo_input.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cbfdbe40",
   "metadata": {},
   "source": [
    "Of course the previous example might look cumbersome. The `Crystal_input` objects can be generated by 'block' texts. 'Block' is a multiple-line string closed by the 'END' keyword. 3 basic blocks are defined in CRYSTAL d12 format: geometry, basis set and SCF. There are sub-blocks in the 3 major blocks that can be defined in a similar way by calling corresponding keywords. Also the whole file is recognized as a block."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1bd7a743",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MGO BULK - GEOMETRY TEST\n",
      "CRYSTAL\n",
      "0 0 0\n",
      "225\n",
      "4.217\n",
      "2\n",
      "12 0.    0.    0.\n",
      "8 0.5   0.5   0.5\n",
      "BASISSET\n",
      "POB-DZVP\n",
      "DFT\n",
      "B3LYP\n",
      "XXLGRID\n",
      "ENDDFT\n",
      "MAXCYCLE\n",
      "200\n",
      "SHRINK\n",
      "12 24\n",
      "TOLINTEG\n",
      "7 7 7 7 14\n",
      "FMIXING\n",
      "70\n",
      "DIIS\n",
      "ENDSCF\n",
      "\n"
     ]
    }
   ],
   "source": [
    "geom_block = \\\n",
    "\"\"\"MGO BULK - GEOMETRY TEST\n",
    "CRYSTAL\n",
    "0 0 0\n",
    "225\n",
    "4.217\n",
    "2\n",
    "12 0.    0.    0.\n",
    "8 0.5   0.5   0.5\n",
    "ENDGEOM\n",
    "\"\"\"\n",
    "\n",
    "bs_block   = \\\n",
    "\"\"\"BASISSET\n",
    "POB-DZVP\n",
    "\"\"\"\n",
    "func_block = \\\n",
    "\"\"\"DFT\n",
    "B3LYP\n",
    "XXLGRID\n",
    "ENDDFT\n",
    "\"\"\"\n",
    "scf_block  = \\\n",
    "\"\"\"TOLINTEG\n",
    "7 7 7 7 14\n",
    "SHRINK\n",
    "12 24\n",
    "MAXCYCLE\n",
    "200\n",
    "FMIXING\n",
    "70\n",
    "DIIS\n",
    "ENDSCF\n",
    "\"\"\"\n",
    "mgo_input = Crystal_input()\n",
    "mgo_input.geom(geom_block)\n",
    "mgo_input.basisset(bs_block)\n",
    "mgo_input.scf(scf_block)\n",
    "mgo_input.scf.dft(func_block) # DFT is a sub-block of SCF block\n",
    "print(mgo_input.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b19db390-4a9b-4f9e-8dd9-811a86bcef02",
   "metadata": {},
   "source": [
    "To set value for keywords (not closed by 'END'),  use `obj.keyword(value)`. 3 types of input parameters are allowed.\n",
    "\n",
    "1. Normal input: Depending on the requirements of the keyword  \n",
    "2. Empty: Print the keyword only  \n",
    "3. 'None': Clean the entry and the keyword.\n",
    "\n",
    "A warning message is printed because the newly added 'NODIIS' conflicts with the original 'DIIS' keyword. The old entry is removed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8ae704fd-118a-45e1-8286-a965df6e5e07",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DFT\n",
      "B3LYP\n",
      "XXLGRID\n",
      "ENDDFT\n",
      "SHRINK\n",
      "12 24\n",
      "TOLINTEG\n",
      "7 7 7 7 14\n",
      "FMIXING\n",
      "30 \n",
      "NODIIS\n",
      "ENDSCF\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/huanyu/apps/anaconda3/envs/crystal_py3.9/lib/python3.9/site-packages/CRYSTALpytools/base/crysd12.py:1231: UserWarning: 'NODIIS' conflicts with the existing 'DIIS'. The old one is deleted.\n",
      "  super().assign_keyword('NODIIS', [], nodiis); return self\n"
     ]
    }
   ],
   "source": [
    "mgo_input.scf.fmixing(30) # edit FMIXING keyword\n",
    "mgo_input.scf.maxcycle(None) # remove MAXCYCLE keyword\n",
    "mgo_input.scf.nodiis() # add NODIIS keyword\n",
    "print(mgo_input.scf.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01c1e947",
   "metadata": {},
   "source": [
    "The user can also use an existing file as a template. In a similar way one can change, delete and substitute keywords. Here a 'keyword-only' OPTGEOM block is defined."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ed435d4f",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MGO BULK - GEOMETRY TEST\n",
      "CRYSTAL\n",
      "0 0 0\n",
      "225\n",
      "4.217\n",
      "2\n",
      "12 0.    0.    0.\n",
      "8 0.5   0.5   0.5\n",
      "OPTGEOM\n",
      "ENDOPT\n",
      "ENDGEOM\n",
      "\n"
     ]
    }
   ],
   "source": [
    "mgo_opt = Crystal_input('crysinp_mgo.d12')\n",
    "mgo_opt.geom.optgeom()\n",
    "print(mgo_opt.geom.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47f15777-4df9-47f2-a7f6-18dd1964955d",
   "metadata": {},
   "source": [
    "Sub-blocks can be automatically added by calling keywords defined within. The object can also be instantiated by calling the classmethod `read_file()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1afdfd66-6abc-42c9-bea0-518884b6c494",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generated by CRYSTALpytools\n",
      "CRYSTAL\n",
      "0 0 0\n",
      "225\n",
      "4.217\n",
      "2\n",
      "12 0.    0.    0.\n",
      "8 0.5   0.5   0.5\n",
      "OPTGEOM\n",
      "TOLDEG\n",
      "0.0003 \n",
      "TOLDEX\n",
      "0.0012 \n",
      "ENDOPT\n",
      "ENDGEOM\n",
      "\n"
     ]
    }
   ],
   "source": [
    "mgo_opt = Crystal_input.read_file('crysinp_mgo.d12')\n",
    "mgo_opt.geom.title('Generated by CRYSTALpytools')\n",
    "mgo_opt.geom.optgeom.toldex(0.0012)\n",
    "mgo_opt.geom.optgeom.toldeg(0.0003)\n",
    "print(mgo_opt.geom.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7568a9d6-e333-4a41-bb2e-a75c0253acb6",
   "metadata": {},
   "source": [
    "Eventually an input file can be written."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "0d1d966c-dcff-4ce9-acf9-70f9c8ff765c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<CRYSTALpytools.crystal_io.Crystal_input at 0x7fdb6d111370>"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mgo_opt.write_file('crysinp_mgo_opt.d12')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "486403f1-d31d-426b-b0f4-6d0c492e3d4d",
   "metadata": {},
   "source": [
    "### Set geometry\n",
    "\n",
    "Geometry input can be set by a CIF file or a pymatgen structure when needed. There are 2 available options:\n",
    "\n",
    "1. Set `keyword='EXTERNAL'` (default) and `Crystal_input` object automatically convert the geometry entry to a gui file with default settings. Recommended.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "f98b64ce-c8c2-4090-8dde-eb60e33ec527",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generated by CRYSTALpytools\n",
      "EXTERNAL\n",
      "ENDGEOM\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/huanyu/apps/anaconda3/envs/crystal_py3.9/lib/python3.9/site-packages/pymatgen/io/cif.py:1287: UserWarning: Issues encountered while parsing CIF: Skipping relative stoichiometry check because CIF does not contain formula keys.\n",
      "  warnings.warn(\"Issues encountered while parsing CIF: \" + \"\\n\".join(self.warnings))\n"
     ]
    }
   ],
   "source": [
    "para = Crystal_input().geom_from_cif('crysinp_para.cif',\n",
    "                                     gui_name='crysinp_para.gui')\n",
    "print(para.geom.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6eea5eb9-c0c7-4111-88e5-15a1d1e94cf5",
   "metadata": {},
   "source": [
    "2. Set `keyword=CRYSTAL`, the input block will be automatically generated. 3D structures only."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "bafc6f03-612b-4ef1-b9d8-a4bfc8d3264b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generated by CRYSTALpytools\n",
      "CRYSTAL\n",
      "0   0   0   \n",
      "14  \n",
      "7.073000     9.166000     12.667000    115.510000   \n",
      "20 \n",
      "1      0.37160000   0.92980000   0.49880000 \n",
      "1      0.24220000   0.76340000   0.33040000 \n",
      "1      0.77660000   0.60000000   0.43090000 \n",
      "1      0.90770000   0.76640000   0.60050000 \n",
      "1      0.79990000   0.53530000   0.25760000 \n",
      "1      0.10820000   0.95930000   0.69510000 \n",
      "1      0.56840000   0.08530000   0.89610000 \n",
      "1      0.29390000   0.07980000   0.85010000 \n",
      "1      0.40860000   0.21910000   0.80230000 \n",
      "6      0.14960000   0.85790000   0.56187000 \n",
      "6      0.24320000   0.85758000   0.48526000 \n",
      "6      0.17040000   0.76206000   0.39004000 \n",
      "6      0.00430000   0.66838000   0.37078000 \n",
      "6      0.90790000   0.67092000   0.44601000 \n",
      "6      0.98060000   0.76560000   0.54106000 \n",
      "6      0.39830000   0.01599000   0.71975000 \n",
      "6      0.41680000   0.10369000   0.82440000 \n",
      "7      0.21229000   0.94984000   0.66089000 \n",
      "8      0.94130000   0.57511000   0.27811000 \n",
      "8      0.54450000   0.00741000   0.69146000 \n",
      "ENDGEOM\n",
      "\n"
     ]
    }
   ],
   "source": [
    "para = Crystal_input().geom_from_cif('crysinp_para.cif',\n",
    "                                     keyword='CRYSTAL')\n",
    "print(para.geom.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d575fa4b-cb13-4e27-b45f-30baa297a988",
   "metadata": {},
   "source": [
    "It should be noted that sequences of atoms of the input geometry are different from d12 blocks. The coordinates might also change during the standarization of unit cell. In ordinary scenarios it would not affect the outcomes.\n",
    "\n",
    "However, extra care must be taken when conventional atomic numbers are set (i.e., when using peudopotentials or different basis sets for the same element). Though `zconv` can be set for `geom_from_cif()` and `geom_from_pmg()` methods, they are not recommended unless the user is very sure about the output indices of atoms with conventional atomic numbers. The developers are working actively for better solutions.\n",
    "\n",
    "### Set basis set\n",
    "\n",
    "The user can set basis set by string (as shown before), a text file or downloading it from [Basis Set Exchange (BSE)](https://www.basissetexchange.org/). Besides, a built-in BS can be called by keyword 'BASISSET'.\n",
    "\n",
    "To download BSs from BSE, the name of basis set and conventional atomic numbers of elements are needed. \n",
    "\n",
    "**Note**\n",
    "\n",
    "**In BSE, the charge information is missing. A neutral atom is always assumed by default, which works well in most cases. To modify the initial charge guess, see below.**\n",
    "\n",
    "**Automatic assignment of charges is available only for all-electron BSs.**\n",
    "\n",
    "Call the wrapper method `bs_user()`, which is equivalent to `basisset.from_bse()`. The downloaded BS is written as user-defined basis sets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "dbe1f740-c284-4aed-b76b-9f8f13195261",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "12 5\n",
      "0 0 6 2.00 1.00\n",
      "  11722.8000000000      0.0019778293\n",
      "   1759.9300000000      0.0151139948\n",
      "    400.8460000000      0.0739107745\n",
      "    112.8070000000      0.2491909140\n",
      "     35.9997000000      0.4879278316\n",
      "     12.1828000000      0.3196618896\n",
      "0 1 6 8.00 1.00\n",
      "    189.1800000000     -0.0032371705      0.0049281299\n",
      "     45.2119000000     -0.0410079060      0.0349887994\n",
      "     14.3563000000     -0.1126000164      0.1407249977\n",
      "      5.1388600000      0.1486330216      0.3336419947\n",
      "      1.9065200000      0.6164970898      0.4449399929\n",
      "      0.7058870000      0.3648290531      0.2692539957\n",
      "0 1 3 2.00 1.00\n",
      "      0.9293400000     -0.2122908985     -0.0224191812\n",
      "      0.2690350000     -0.1079854570      0.1922708390\n",
      "      0.1173790000      1.1758449770      0.8461802916\n",
      "0 1 1 0.00 1.00\n",
      "      0.0421061000      1.0000000000      1.0000000000\n",
      "0 3 1 0.00 1.00\n",
      "      0.1750000000      1.0000000000\n",
      "8 4\n",
      "0 0 6 2.00 1.00\n",
      "   5484.6716600000      0.0018310744\n",
      "    825.2349460000      0.0139501722\n",
      "    188.0469580000      0.0684450781\n",
      "     52.9645000000      0.2327143360\n",
      "     16.8975704000      0.4701928980\n",
      "      5.7996353400      0.3585208530\n",
      "0 1 3 6.00 1.00\n",
      "     15.5396162500     -0.1107775495      0.0708742682\n",
      "      3.5999335860     -0.1480262627      0.3397528391\n",
      "      1.0137617500      1.1307670150      0.7271585773\n",
      "0 1 1 0.00 1.00\n",
      "      0.2700058226      1.0000000000      1.0000000000\n",
      "0 3 1 0.00 1.00\n",
      "      0.8000000000      1.0000000000\n",
      "99 0\n",
      "ENDBS\n",
      "\n"
     ]
    }
   ],
   "source": [
    "mgo_input = Crystal_input.read_file('crysinp_mgo.d12')\n",
    "\n",
    "mgo_input.bs_user('6-31G*', z=[12, 8])\n",
    "print(mgo_input.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "086b2812-ac2e-4b08-beb7-2deeb360fe47",
   "metadata": {},
   "source": [
    "The same method can be used to interprete basis set files, equivalent to  the `basisset.from_file()` method. Format string is consistent with [BSE python API](https://molssi-bse.github.io/basis_set_exchange/bse_cli.html#list-formats)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "4f82a27e-105d-4d98-976c-b802dab94b10",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "8 2\n",
      "0 0 3 2.00 1.00\n",
      "    130.7093214000      0.1543289673\n",
      "     23.8088660500      0.5353281423\n",
      "      6.4436083130      0.4446345422\n",
      "0 1 3 6.00 1.00\n",
      "      5.0331513190     -0.0999672292      0.1559162750\n",
      "      1.1695961250      0.3995128261      0.6076837186\n",
      "      0.3803889600      0.7001154689      0.3919573931\n",
      "12 3\n",
      "0 0 3 2.00 1.00\n",
      "    299.2374137000      0.1543289673\n",
      "     54.5064684500      0.5353281423\n",
      "     14.7515775200      0.4446345422\n",
      "0 1 3 8.00 1.00\n",
      "     15.1218235200     -0.0999672292      0.1559162750\n",
      "      3.5139865790      0.3995128261      0.6076837186\n",
      "      1.1428574980      0.7001154689      0.3919573931\n",
      "0 1 3 2.00 1.00\n",
      "      1.3954482930     -0.2196203690      0.0105876043\n",
      "      0.3893265318      0.2255954336      0.5951670053\n",
      "      0.1523797659      0.9003984260      0.4620010120\n",
      "99 0\n",
      "ENDBS\n",
      "\n"
     ]
    }
   ],
   "source": [
    "mgo_input.bs_user('bs_mgo.gbs', fmt='gaussian94')\n",
    "print(mgo_input.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "965949c5-632b-4f21-84b2-6bc1b1d587f1",
   "metadata": {},
   "source": [
    "In some rare cases, the user might want to change the charge of BS shells to get ions and a better initial guess of charge density. A dictionary is used to define the charge.\n",
    "\n",
    "- Key: Conventional atomic number  \n",
    "- Value: nshell\\*1 list of charges. Must be consistent with BS definitions.\n",
    "\n",
    "Define Mg$^{2+}$ and O$^{2-}$ ions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3f57294b-728d-416b-9269-1da054ed9f4c",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "8 2\n",
      "0 0 3 2.00 1.00\n",
      "    130.7093214000      0.1543289673\n",
      "     23.8088660500      0.5353281423\n",
      "      6.4436083130      0.4446345422\n",
      "0 1 3 8.00 1.00\n",
      "      5.0331513190     -0.0999672292      0.1559162750\n",
      "      1.1695961250      0.3995128261      0.6076837186\n",
      "      0.3803889600      0.7001154689      0.3919573931\n",
      "12 3\n",
      "0 0 3 2.00 1.00\n",
      "    299.2374137000      0.1543289673\n",
      "     54.5064684500      0.5353281423\n",
      "     14.7515775200      0.4446345422\n",
      "0 1 3 8.00 1.00\n",
      "     15.1218235200     -0.0999672292      0.1559162750\n",
      "      3.5139865790      0.3995128261      0.6076837186\n",
      "      1.1428574980      0.7001154689      0.3919573931\n",
      "0 1 3 0.00 1.00\n",
      "      1.3954482930     -0.2196203690      0.0105876043\n",
      "      0.3893265318      0.2255954336      0.5951670053\n",
      "      0.1523797659      0.9003984260      0.4620010120\n",
      "99 0\n",
      "ENDBS\n",
      "\n"
     ]
    }
   ],
   "source": [
    "chg = {8  : [2.0, 8.0],\n",
    "       12 : [2.0, 8.0, 0.0]}\n",
    "mgo_input.bs_user('bs_mgo.gbs', fmt='gaussian94', charge=chg)\n",
    "print(mgo_input.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96496e1b-34f8-438c-9409-0270b2a4ccc9",
   "metadata": {},
   "source": [
    "Convert the Gaussian-formatted basis set collection and write them into the external 'crysinp_BASISSETS.DAT' file in CRYSTAL format, with the title 'STO-3G from BSE'."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "6a66fa70-8d06-46c8-ab0d-7ea56920f498",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<CRYSTALpytools.crystal_io.Crystal_input at 0x7fdbc938ff70>"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "chg = {8  : [2.0, 8.0],\n",
    "       12 : [2.0, 8.0, 0.0]}\n",
    "mgo_input.bs_user('bs_mgo.gbs', fmt='gaussian94', charge=chg,\n",
    "                  BSfile='crysinp_BASISSETS.DAT', title='STO-3G from BSE')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39ea3193-6ddb-4474-8cac-8686c22c6957",
   "metadata": {},
   "source": [
    "The input keywords are changed accordingly."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "62a90394-fd6d-46d5-9b15-4bea43bb93b3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "BASISSET\n",
      "STO-3G from BSE \n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(mgo_input.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "46c7eccf-24c7-454b-a982-9b381ef070ed",
   "metadata": {},
   "source": [
    "Similarly, effective core pseudopotential can be defined. The automatic charge assignment of atomic charge is also available for ECP BSs.\n",
    "\n",
    "Defining BaO basis set with Stuttgart ECP (Only Ba, O is not supported in CRYSTAL and causes error). Use `append=True` to attach new entries."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "0bfaa44a-8fd1-4965-b908-b58f0339a2c3",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "356 11\n",
      "STUTSC\n",
      "0 0 3 2.00 1.00\n",
      "      2.3961900000     -5.9288950000\n",
      "      2.2433050000      6.6469340000\n",
      "      0.7174020000     -0.5514370000\n",
      "0 0 1 2.00 1.00\n",
      "      0.2784460000      1.0000000000\n",
      "0 0 1 0.00 1.00\n",
      "      0.0431880000      1.0000000000\n",
      "0 0 1 0.00 1.00\n",
      "      0.0197980000      1.0000000000\n",
      "0 2 3 6.00 1.00\n",
      "      2.9267420000      0.7633590000\n",
      "      2.5207180000     -1.0220140000\n",
      "      0.5240950000      0.6498360000\n",
      "0 2 1 0.00 1.00\n",
      "      0.2034280000      1.0000000000\n",
      "0 2 1 0.00 1.00\n",
      "      0.0479960000      1.0000000000\n",
      "0 2 1 0.00 1.00\n",
      "      0.0200950000      1.0000000000\n",
      "0 3 3 0.00 1.00\n",
      "      0.9663150000     -0.9089380000\n",
      "      0.8938280000      0.9472400000\n",
      "      0.2731950000      0.3220570000\n",
      "0 3 2 0.00 1.00\n",
      "      0.1038910000      0.4732600000\n",
      "      0.0355780000      0.3659770000\n",
      "0 4 1 0.00 1.00\n",
      "      0.6970000000      1.0000000000\n",
      "8 4\n",
      "0 0 6 2.00 1.00\n",
      "   5484.6716600000      0.0018310744\n",
      "    825.2349460000      0.0139501722\n",
      "    188.0469580000      0.0684450781\n",
      "     52.9645000000      0.2327143360\n",
      "     16.8975704000      0.4701928980\n",
      "      5.7996353400      0.3585208530\n",
      "0 1 3 6.00 1.00\n",
      "     15.5396162500     -0.1107775495      0.0708742682\n",
      "      3.5999335860     -0.1480262627      0.3397528391\n",
      "      1.0137617500      1.1307670150      0.7271585773\n",
      "0 1 1 0.00 1.00\n",
      "      0.2700058226      1.0000000000      1.0000000000\n",
      "0 3 1 0.00 1.00\n",
      "      0.8000000000      1.0000000000\n",
      "99 0\n",
      "ENDBS\n",
      "\n"
     ]
    }
   ],
   "source": [
    "bao_input = Crystal_input()\n",
    "bao_input.bs_user('Stuttgart RSC 1997', z=[356],\n",
    "                  ECP={356 : 'STUTSC'})\n",
    "bao_input.bs_user('6-31G*', z=[8], append=True)\n",
    "print(bao_input.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d2eb231-019a-409d-b3ef-2088e907a4c8",
   "metadata": {},
   "source": [
    "To set conventional atomic numbers for basis sets, the user can use `bs_user()` twice with `append=True`. Here a 'def2-SVP' basis set is defined for H atom with atomic number 101."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d41385f6-e866-4151-afcf-41b62daeb291",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6 4\n",
      "0 0 6 2.00 1.00\n",
      "   3047.5248800000      0.0018347371\n",
      "    457.3695180000      0.0140373228\n",
      "    103.9486850000      0.0688426223\n",
      "     29.2101553000      0.2321844432\n",
      "      9.2866629600      0.4679413484\n",
      "      3.1639269600      0.3623119853\n",
      "0 1 3 4.00 1.00\n",
      "      7.8682723500     -0.1193324198      0.0689990666\n",
      "      1.8812885400     -0.1608541517      0.3164239610\n",
      "      0.5442492580      1.1434564380      0.7443082909\n",
      "0 1 1 0.00 1.00\n",
      "      0.1687144782      1.0000000000      1.0000000000\n",
      "0 3 1 0.00 1.00\n",
      "      0.8000000000      1.0000000000\n",
      "1 2\n",
      "0 0 3 1.00 1.00\n",
      "     18.7311369600      0.0334946043\n",
      "      2.8253943650      0.2347269535\n",
      "      0.6401216923      0.8137573261\n",
      "0 0 1 0.00 1.00\n",
      "      0.1612777588      1.0000000000\n",
      "101 3\n",
      "0 0 3 1.00 1.00\n",
      "     13.0107010000      0.0196821580\n",
      "      1.9622572000      0.1379652400\n",
      "      0.4445379600      0.4783193500\n",
      "0 0 1 0.00 1.00\n",
      "      0.1219496200      1.0000000000\n",
      "0 2 1 0.00 1.00\n",
      "      0.8000000000      1.0000000000\n",
      "99 0\n",
      "ENDBS\n",
      "\n"
     ]
    }
   ],
   "source": [
    "obj = Crystal_input()\n",
    "obj.bs_user('6-31G*', [6, 1])\n",
    "obj.bs_user('def2-SVP', [101], append=True)\n",
    "print(obj.basisset.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "60821315-d443-4e47-940e-48add6ec5b4b",
   "metadata": {},
   "source": [
    "In principle, to use 'BASISSET' keyword, the `basisset.basisset()` should be called. A shortcut `bs_keyword` is added. A warning message is triggered because of the old definition of basis sets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "e1174d13-3da9-4e33-92bd-71421152f87a",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MGO BULK - GEOMETRY TEST\n",
      "CRYSTAL\n",
      "0 0 0\n",
      "225\n",
      "4.217\n",
      "2\n",
      "12 0.    0.    0.\n",
      "8 0.5   0.5   0.5\n",
      "BASISSET\n",
      "pob-DZVP \n",
      "DFT\n",
      "B3LYP\n",
      "XXLGRID\n",
      "ENDDFT\n",
      "MAXCYCLE\n",
      "200\n",
      "SHRINK\n",
      "12 24\n",
      "TOLINTEG\n",
      "7 7 7 7 14\n",
      "FMIXING\n",
      "70\n",
      "DIIS\n",
      "ENDSCF\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/huanyu/apps/anaconda3/envs/crystal_py3.9/lib/python3.9/site-packages/CRYSTALpytools/crystal_io.py:229: UserWarning: User's definition of baisis set is not empty. It will be covered by 'BASISSET' keyword.\n",
      "  self.basisset.basisset(keyword)\n"
     ]
    }
   ],
   "source": [
    "mgo_input = Crystal_input.read_file('crysinp_mgo.d12')\n",
    "mgo_input.bs_keyword('pob-DZVP')\n",
    "print(mgo_input.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2efc2840-798d-4631-a3c1-b3ab18082a23",
   "metadata": {},
   "source": [
    "## 'crystal_io.Properties_input' class\n",
    "\n",
    "**NOTE**\n",
    "\n",
    "**Though developers are working hard to implement all the keywords, due to the limit of time and developing forces, not all keywords has been implemented. Please confirm that in module-specific documentations or contact developers via [GitHub](https://github.com/crystal-code-tools/CRYSTALpytools).**\n",
    "\n",
    "### Basic file generation\n",
    "\n",
    "The `Properties_input` class is developed in a similar style as the  `Crystal_input` class. It prepares input 'd3' files for 'properties' calculations of CRYSTAL package.\n",
    "\n",
    "An instance is generated by manually calling keywords 'NEWK', 'ECHG', 'DOSS' and 'BAND' for charge density, DOS and band calculations. As pointed out in CRYSTAL user manual, 'BAND' must be put before 'NEWK', while in the following code, `newk()` is called first. The generated output automatically corrects this issue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "b0fcafb0-70ec-4163-8501-5f8b8aa9ecda",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<CRYSTALpytools.crystal_io.Properties_input at 0x7fdb64540910>"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from CRYSTALpytools.crystal_io import Properties_input\n",
    "\n",
    "inp = Properties_input()\n",
    "# NEWK\n",
    "inp.newk(12, 24, 1, 0)\n",
    "# ECHG\n",
    "inp.echg(0, 95) # N point of MAPNET set to 95. Default 100\n",
    "inp.echg.coordina([-4., -4., 0.], [4, -4, 0.], [4., 4., 0.])\n",
    "inp.echg.margins(1.5, 1.5, 1.5, 1.5)\n",
    "inp.echg.rectangu()\n",
    "# DOSS\n",
    "inp.doss(0, 600, 203, 224, 1, 12, 0)\n",
    "# BAND\n",
    "inp.band('Band structure', 3, 4, 200, 1, 26, 1, 0,\n",
    "         [[[0, 0, 0], [2, 0, 0]],\n",
    "          [[2, 0, 0], [2, 2, 2]],\n",
    "          [[2, 2, 2], [1, 0, 2]]])\n",
    "\n",
    "# Write the input\n",
    "inp.write_file('propinp_1.d3')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d1734bcb-c312-4130-83cc-d0e027a50214",
   "metadata": {},
   "source": [
    "The `Properties_input` class can be instantiated from file or text in the same way as `Crystal_input`. Please refer to the examples above.\n",
    "\n",
    "### 'make_band_block' short cut method\n",
    "\n",
    "It is a shortcut method parameterized for quick generations of band structure block. It accepts either list definition or pymatgen `HighSymmKpath` object.\n",
    "\n",
    "The following example shows how to prepare band structure plot from geometry optimization output of diamond."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "8765465d-62b7-4a78-9182-0db5ab2b9041",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "BAND\n",
      "BAND STRUCTURE CALCULATION \n",
      "10 8 200 1 26 1 0 \n",
      "0  0  0    4  0  4    \n",
      "4  0  4    4  2  6    \n",
      "4  2  6    3  3  6    \n",
      "3  3  6    0  0  0    \n",
      "0  0  0    4  4  4    \n",
      "4  4  4    5  2  5    \n",
      "5  2  5    4  2  6    \n",
      "4  2  6    4  4  4    \n",
      "4  4  4    3  3  6    \n",
      "3  3  6    5  2  5    \n",
      "END\n",
      "\n"
     ]
    }
   ],
   "source": [
    "from pymatgen.symmetry.bandstructure import HighSymmKpath\n",
    "from CRYSTALpytools.crystal_io import Crystal_output, Properties_input\n",
    "\n",
    "dia = Crystal_output('propinp_diamondcrys.out').get_geometry(initial=False)\n",
    "k_path = HighSymmKpath(dia.get_pcel([[-1, 1, 1], [1, -1, 1], [1, 1, -1]]))\n",
    "\n",
    "inp = Properties_input().make_band_block(k_path, 200, 1, 26)\n",
    "print(inp.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e838e1dc-6f28-42a9-9575-805a69cc16b1",
   "metadata": {},
   "source": [
    "### 'make_doss_block' shortcut method\n",
    "\n",
    "`make_doss_block` is also a shortcut method with parameters set. It allows specification of projected elements with `projections` entry, when output file of 'crystal' calculation is available. Useful for big systems."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "c700b501-ec46-4eb2-85c1-bd9b603b4771",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "NEWK\n",
      "12 24 \n",
      "1 0 \n",
      "DOSS\n",
      "1 200 1 26 2 12 1 \n",
      "-4 3 4 5 6 \n",
      "END\n",
      "\n"
     ]
    }
   ],
   "source": [
    "inp = Properties_input()\n",
    "\n",
    "inp.newk(12, 24, 1, 0)\n",
    "inp.make_doss_block(band_range=[1, 26], projections=['O'],\n",
    "                    output_file='propinp_Mg2O2crys.out')\n",
    "print(inp.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0d3b05f-7fd4-46e1-bf67-62f952e76d65",
   "metadata": {},
   "source": [
    "## Advanced: Repeated keywords and 'append' property\n",
    "\n",
    "Both `Crystal_input` and `Properties_input` classes are inherited from the same `BlockBASE` object defined in 'base.inputbase' script. Keywords are protected by block objects and repeating the same keyword in the same block overwrites the previous entry. Therefore, in principle, all the keywords should appear only once in the same block.\n",
    "\n",
    "So far as the developers have been aware of, that causes 2 issues:\n",
    "\n",
    "1. In `Crystal_input.geom` block, the keyword 'MOLECULE' refers to both the modelling keyword for 0D systems and editing keyword to substracte molecules from molecular crystal. The method of the latter one should be called as `molecule2()` but the original keyword is recognized for file I/O."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "72ef9b0b-f5eb-4fa5-89fd-625e4fdd249b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generated by CRYSTALpytools\n",
      "CRYSTAL\n",
      "0   0   0\n",
      "14\n",
      "7.073000     9.166000     12.667000    115.510000\n",
      "20\n",
      "1      0.37160000   0.92980000   0.49880000\n",
      "1      0.24220000   0.76340000   0.33040000\n",
      "1      0.77660000   0.60000000   0.43090000\n",
      "1      0.90770000   0.76640000   0.60050000\n",
      "1      0.79990000   0.53530000   0.25760000\n",
      "1      0.10820000   0.95930000   0.69510000\n",
      "1      0.56840000   0.08530000   0.89610000\n",
      "1      0.29390000   0.07980000   0.85010000\n",
      "1      0.40860000   0.21910000   0.80230000\n",
      "6      0.14960000   0.85790000   0.56187000\n",
      "6      0.24320000   0.85758000   0.48526000\n",
      "6      0.17040000   0.76206000   0.39004000\n",
      "6      0.00430000   0.66838000   0.37078000\n",
      "6      0.90790000   0.67092000   0.44601000\n",
      "6      0.98060000   0.76560000   0.54106000\n",
      "6      0.39830000   0.01599000   0.71975000\n",
      "6      0.41680000   0.10369000   0.82440000\n",
      "7      0.21229000   0.94984000   0.66089000\n",
      "8      0.94130000   0.57511000   0.27811000\n",
      "8      0.54450000   0.00741000   0.69146000\n",
      "ATOMORDE\n",
      "ENDGEOM\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/huanyu/apps/anaconda3/envs/crystal_py3.9/lib/python3.9/site-packages/pymatgen/io/cif.py:1287: UserWarning: Issues encountered while parsing CIF: Skipping relative stoichiometry check because CIF does not contain formula keys.\n",
      "  warnings.warn(\"Issues encountered while parsing CIF: \" + \"\\n\".join(self.warnings))\n"
     ]
    }
   ],
   "source": [
    "from CRYSTALpytools.crystal_io import Crystal_input\n",
    "\n",
    "inp = Crystal_input().geom_from_cif('crysinp_para.cif', keyword='CRYSTAL')\n",
    "inp.geom.atomorde()\n",
    "inp.geom.molecule2(1, [[1 ,0, 0, 0]])\n",
    "inp.write_file('adv_molecule2.d12')\n",
    "\n",
    "inp = Crystal_input.read_file('adv_molecule2.d12')\n",
    "inp.geom.molecule2(None)\n",
    "print(inp.geom.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c302b02b-8759-4806-9661-6255ec664422",
   "metadata": {},
   "source": [
    "2. For charge difference maps, 'ECHG' keyword is defined twice to get charge differences. The user can run 2 separate calculations and call `electronics.ChargeDensity` class to get difference maps, or define then `Properties_input` object with 'append' subblocks, which can be set just as `Properties_input` objects. The `Properties_input` object allows 5 'append' blocks, i.e., `append1` to `append5`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "07eb9c2e-6029-4ad8-b932-3503723c5f47",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ECHG\n",
      "0\n",
      "100\n",
      "COORDINA\n",
      "-4.000000 -4.000000  0.000000  \n",
      " 4.000000 -4.000000  0.000000  \n",
      " 4.000000  4.000000  0.000000  \n",
      "RECTANGU\n",
      "MARGINS\n",
      "1.5 1.5 1.5 1.5 \n",
      "END\n",
      "PATO\n",
      "0 0 \n",
      "ECHG\n",
      "0\n",
      "100\n",
      "COORDINA\n",
      "-4.000000 -4.000000  0.000000  \n",
      " 4.000000 -4.000000  0.000000  \n",
      " 4.000000  4.000000  0.000000  \n",
      "RECTANGU\n",
      "MARGINS\n",
      "1.5 1.5 1.5 1.5 \n",
      "END\n",
      "END\n",
      "\n"
     ]
    }
   ],
   "source": [
    "from CRYSTALpytools.crystal_io import Properties_input\n",
    "\n",
    "inp = Properties_input()\n",
    "inp.echg(0, 100)\n",
    "inp.echg.coordina([-4., -4., 0.], [4, -4, 0.], [4., 4., 0.])\n",
    "inp.echg.margins(1.5, 1.5, 1.5, 1.5)\n",
    "inp.echg.rectangu()\n",
    "\n",
    "inp.append1.pato(0, 0)\n",
    "inp.append1.echg(0, 100)\n",
    "inp.append1.echg.coordina([-4., -4., 0.], [4, -4, 0.], [4., 4., 0.])\n",
    "inp.append1.echg.margins(1.5, 1.5, 1.5, 1.5)\n",
    "inp.append1.echg.rectangu()\n",
    "\n",
    "inp.write_file('adv_dCHG.d3')\n",
    "print(inp.data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8dc6f9e5-ae73-4ea7-9ef7-9cc3ef755aa5",
   "metadata": {},
   "source": [
    "For more details, please refer to the [API documentations](https://crystal-code-tools.github.io/CRYSTALpytools/crystalpytools.crystal_io.html) and the developer's documentation of [InputBASE](https://crystal-code-tools.github.io/CRYSTALpytools/crystalpytools.base.inputbase.html), [Crystal_inputBASE](https://crystal-code-tools.github.io/CRYSTALpytools/crystalpytools.base.crysd12.html) and [Properties_inputBASE](https://crystal-code-tools.github.io/CRYSTALpytools/crystalpytools.base.propd3.html) classes. For more information about basis sets, also check the [Basis Set: Advanced](basisset_advanced.ipynb) example book."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "crystal_py3.9",
   "language": "python",
   "name": "crystal_py3.9"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.19"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
